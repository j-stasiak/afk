const std = @import("std");

const rl = @import("raylib");

const TERMINAL_BUFFER_SIZE = 128;

pub const Terminal = struct {
    position: rl.Vector2,
    size: rl.Vector2,
    buffer: [TERMINAL_BUFFER_SIZE:0]u8 = .{0} ** TERMINAL_BUFFER_SIZE,
    text_index: usize = 0,

    pub fn draw(self: *Terminal) void {
        rl.drawRectangleV(self.position, self.size, .gray);
        rl.drawText(">", @as(i32, @intFromFloat(self.position.x)) + 24, @as(i32, @intFromFloat(self.position.y)) + @divFloor(@as(i32, @intFromFloat(self.size.y)) - 24, 2), 24, .light_gray);
        rl.drawText(&self.buffer, @as(i32, @intFromFloat(self.position.x)) + 48, @as(i32, @intFromFloat(self.position.y)) + @divFloor(@as(i32, @intFromFloat(self.size.y)) - 24, 2), 24, .white);
    }

    pub fn update(self: *Terminal) !void {
        const key = rl.getKeyPressed();

        const keyInt: c_int = @intFromEnum(key);
        if (keyInt >= 32 and keyInt <= 125) {
            self.buffer[self.text_index] = @intCast(keyInt);
            self.text_index += 1;
        }

        if (rl.isKeyReleased(.backspace) and self.text_index > 0) {
            self.buffer[self.text_index - 1] = 0;
            self.text_index -= 1;
        }

        if (rl.isKeyReleased(.enter)) {
            try self.process_command();
            for (self.buffer, 0..) |_, i| {
                self.buffer[i] = 0;
            }
            self.text_index = 0;
        }
    }

    fn process_command(self: *Terminal) !void {
        const command = self.buffer[0..self.text_index];
        std.debug.print("{s}\n", .{command});
        std.debug.print("{}\n", .{std.mem.eql(u8, self.buffer[0.. :0], "QUIT")});
        if (std.mem.eql(u8, command, "QUIT")) {
            std.debug.print("{s}", .{command});
            rl.closeWindow();
        }
    }
};
